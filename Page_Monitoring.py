import requestsfrom bs4 import BeautifulSoupimport timeimport smtplib, ssl url_sign_in = "https://admissions.42lyon.fr/users/sign_in" url_monitoring = "https://admissions.42lyon.fr/users/736897/introductions_users"email_recipient = "theoarini000@gmail.com"email_sender = email_recipientemail_password = "jrby kdgs heht nzea" # mdp apppassword_42 = "Wh!cQCdVw*H7X%8t"smtp_address = 'smtp.gmail.com'smtp_port = 465 #SSLtoken = Noneserver = NoneCookieJar = Nonedef send_email():    """fonction qui envoi un mail quand la fonction page_monitoring lui demande"""    try:                context = ssl.create_default_context()        server = smtplib.SMTP_SSL(smtp_address, smtp_port, context=context)                    server.login(email_sender, email_password)        server.sendmail(email_sender, email_recipient, 'DATE CHECK')        server.quit()        print("E-mail envoyé avec succès")    except Exception as e:        print(f"Woops ! Une erreur lors de l'envoi de l'e-mail : {e}")        def data_recovery(url_monitoring, url_sign_in):    """fonction qui récupère les données pour que la fonction page_monitoring les comparent avec l'envoi précédent"""            try:                session = requests.session()        response = session.get(url_sign_in)                if response.status_code == 200:                      soup = BeautifulSoup(response.text, "html.parser")                       token = soup.find('input', {'name': 'authenticity_token'})['value']                      cookies = response.cookies                   login = {               'user[email]': email_sender,               'user[password]': password_42,                'authenticity_token': token,               'utf8': 'UTF-8'           }                         session.post(url_sign_in, data=login)            requests.post(url_monitoring, cookies=cookies)                      response2 = session.get(url_monitoring)           if response2.status_code == 200:           # Contenu HTML de la page après la connexion               html = response2.text               return html    except requests.exceptions.RequestException as e:                print(f"Woops ! Une erreur de requête s'est produite : {str(e)}")        return Nonedef page_monitoring():    """fonction qui raffraichit la page et se sert de la fonction data_recovery puis de la fonction send_email quand il observe un     changement tout en se connectant via les variables email et password"""        previous_content = None    while True:                current_content = data_recovery(url_monitoring, url_sign_in)        if current_content:                        if previous_content is None:                                previous_content = current_content                            else:                                if current_content != previous_content:                                        send_email("La page a changé", f"La page {url_monitoring} a été modifiée.")                    previous_content = current_content        time.sleep(3600)